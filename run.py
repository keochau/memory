import Tkinter as tkimport os, sqlite3from random import randintclass Application(tk.Frame):	def __init__(self, master=None):		tk.Frame.__init__(self, master)		self.phase = "" # welcome/instructions/running		self.max_phrases = 5 # maximum number of questions asked before quiz is ended.		self.sleep_duration  = 10 * 1000 # no. of milliseconds to sleep (secs * 1000).		self.num_phrases = 0 # tracker to track number of questions asked.		self.num_phrases_correct = 0 #tracker to track number of correct questions answered.		self.last_phrase = "" #keep track of last phrase		self.grid()		self.create_widgets()		self.show_welcome()		print("initializing main widget")#open local sqlite database and returns the connection and cursor	def opendb(self):		sql = ""		if os.path.exists("phrase.db") == False:			sql = "create table tests(num_phrases int, num_phrases_correct int, correct_per float);"		conn = sqlite3.connect("phrase.db")		cursor = conn.cursor()		if sql != "":			cursor.execute(sql)		return conn, cursor	def create_widgets(self):		# create the widgets		#self.quit_button = tk.Button(self, text="Quit", command=self.quit)		self.lbltitle = tk.Label(self, text="Title Bar", width=100)		self.lblcontent = tk.Label(self, text="Content", width=100, height=10, font="Verdana 10 bold")		self.txtphrase = tk.Entry(self)		self.btnleft = tk.Button(self, text="Left", width=15, height=3, command=self.btnleft_click)		self.btncenter = tk.Button(self, text="Center", width=15, height=3, command=self.btncenter_click)		self.btnright = tk.Button(self, text="Right", width=15, height=3, command=self.btnright_click)		#position the widgets		self.lbltitle.grid(row=0, column=0, columnspan=3)		self.lblcontent.grid(row=1, column=0, columnspan=3)		self.txtphrase.grid(row=2, column=0, columnspan=3, pady=10)		self.btnleft.grid(row=3, column=0)		self.btncenter.grid(row=3, column=1)		self.btnright.grid(row=3, column=2)	# show initial welcome screen	def show_welcome(self):		self.lbltitle['text'] = "Welcome to this Short Term Memory Test"		self.lblcontent['text'] = "This module tests how well your short term memory skills are and compares your results to other participants."		self.btncenter['text'] = "Continue"		self.phase = "welcome"		print("phase set to " + self.phase)		self.btnleft.grid_remove()		self.btnright.grid_remove()		self.txtphrase.grid_remove()		#self.btnleft.grid()	def show_instructions(self):		self.phase = "instructions"		self.lbltitle['text'] = "Instructions"		self.lblcontent["text"] = "\n\nYou will have 10 seconds to memorize each phrase before it disappears.\n\nAfterwards you can type what you remember.\n\nClick begin test to start the test."		self.btncenter['text'] = "Begin Test"	def start_test(self):		#TODO: create stats for new question		self.phase = "running"		self.num_phrases = 0		self.num_phrases_correct = 0		self.btncenter.grid_remove()		self.btnright['text'] = "Next Question"		self.next_phrase()	def end_test(self):		self.phase = "ended"		self.txtphrase.grid_remove()		self.btnleft.grid()		self.btnleft['text'] = "Quit"		correct_per = float(self.num_phrases_correct) / self.max_phrases * 100		#TODO: fetch historical stats from database to compare current user:		conn, cursor = self.opendb()		#tot_tests = 19 #total number of tests taken.		cursor.execute("select count(*) from tests")		tot_tests = cursor.fetchone()[0]		#less_than_curr_user = 0 #how many of them scored less than this current user.		cursor.execute("select count(*) from tests where correct_per < " + str(correct_per))		less_than_curr_user = cursor.fetchone()[0]		print("correct_per:", correct_per)		print("tot_tests:" , tot_tests)		print("less_than_curr_user:" , less_than_curr_user)		better_per = 0 if tot_tests==0 else float(less_than_curr_user)/tot_tests * 100		self.lbltitle['text'] = "You have scored better than " + str(round(better_per,2)) + "% of test takers!"		self.lblcontent['text'] = "You got " + str(self.num_phrases_correct) + "/" + str(self.max_phrases) + " questions correct.\n\nClick Retake to take this test again. Click quit to exit."		self.btnleft['text'] = "Quit"		self.btnright['text'] = "Retake"		#TODO: update stats of current test to database		cursor.execute("insert into tests values(?,?,?)", (self.num_phrases, self.num_phrases_correct, correct_per))		conn.commit()		print("record inserted")	def next_phrase(self):		self.txtphrase.grid_remove()		self.txtphrase.delete(0, tk.END)		self.btnright.grid_remove()		self.lbltitle['text'] = ""		nchars = randint(5, 8)		phrase = ""		for i in range(nchars):			rchar = randint(97,122) #a-z			phrase += chr(rchar)		self.lblcontent['text'] = phrase		self.last_phrase = phrase		#self.after(7000, self.show_phrase_controls)		self.after(self.sleep_duration, self.show_phrase_controls)	def show_phrase_controls(self):		self.lblcontent['text'] = ""		self.btnright.grid()		self.txtphrase.grid()		self.txtphrase.focus_set()			def btnleft_click(self):		if self.btnleft['text'] == "Quit":			exit()	def btncenter_click(self):		if self.phase == "welcome": # we are on the welcome screen, show next screen.			self.show_instructions()		elif self.phase == "instructions": # we are on instructions screen, so start the test.			self.start_test()	def btnright_click(self):		if self.phase == "running": # do this only if a test is running			self.num_phrases += 1			#TODO: check whether user entered the phrase correctly and add it to stats.			print("1:" + self.last_phrase)			print("2:" + self.txtphrase.get())			if self.last_phrase == self.txtphrase.get():				print("Correct Phrase!")				self.num_phrases_correct += 1			else:				print("Incorrect Phrase!")						if self.num_phrases >= self.max_phrases:				self.end_test()			else:				self.next_phrase()		elif self.phase == "ended": # retake test			#TODO: reset all stats and counters.			self.num_phrases = 0			self.num_phrases_correct = 0			self.phase = "running"			self.btnleft.grid_remove()			#self.next_phrase()			self.start_test()app = Application()app.master.title("Short Term Memory Test")app.mainloop()